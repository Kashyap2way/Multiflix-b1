{"version":3,"file":"index.js","sources":["../src/tokenParser.ts","../src/autoRefreshTokenCredential.ts","../src/staticTokenCredential.ts","../src/azureCommunicationTokenCredential.ts","../src/credential/cryptoUtils.ts","../src/credential/communicationAccessKeyCredentialPolicy.ts","../src/credential/communicationAuthPolicy.ts","../src/credential/connectionString.ts","../src/credential/clientArguments.ts","../src/identifierModels.ts","../src/identifierModelSerializer.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AccessToken } from \"@azure/core-auth\";\nimport { jwtDecode } from \"jwt-decode\";\n\ninterface JwtToken {\n  exp: number;\n}\n\nexport const parseToken = (token: string): AccessToken => {\n  const { exp } = jwtDecode<JwtToken>(token);\n  return {\n    token,\n    expiresOnTimestamp: exp * 1000,\n  };\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { CommunicationGetTokenOptions, TokenCredential } from \"./communicationTokenCredential\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { AccessToken } from \"@azure/core-auth\";\nimport { parseToken } from \"./tokenParser\";\n\n/**\n * Options for auto-refreshing a Communication Token credential.\n */\nexport interface CommunicationTokenRefreshOptions {\n  /**\n   * Callback function that returns a string JWT token acquired from the Communication Identity API.\n   * The returned token must be valid (expiration date must be in the future).\n   */\n  tokenRefresher: (abortSignal?: AbortSignalLike) => Promise<string>;\n\n  /**\n   * Optional token to initialize.\n   */\n  token?: string;\n\n  /**\n   * Indicates whether the token should be proactively renewed prior to expiry or only renew on demand.\n   * By default false.\n   */\n  refreshProactively?: boolean;\n}\n\nconst expiredToken = { token: \"\", expiresOnTimestamp: -10 };\nconst minutesToMs = (minutes: number): number => minutes * 1000 * 60;\nconst defaultExpiringSoonInterval = minutesToMs(10);\nconst defaultRefreshAfterLifetimePercentage = 0.5;\n\nexport class AutoRefreshTokenCredential implements TokenCredential {\n  private readonly refresh: (abortSignal?: AbortSignalLike) => Promise<string>;\n  private readonly refreshProactively: boolean;\n  private readonly expiringSoonIntervalInMs: number = defaultExpiringSoonInterval;\n  private readonly refreshAfterLifetimePercentage = defaultRefreshAfterLifetimePercentage;\n\n  private currentToken: AccessToken;\n  private activeTimeout: ReturnType<typeof setTimeout> | undefined;\n  private activeTokenFetching: Promise<string> | null = null;\n  private activeTokenUpdating: Promise<void> | null = null;\n  private disposed = false;\n\n  constructor(refreshArgs: CommunicationTokenRefreshOptions) {\n    const { tokenRefresher, token, refreshProactively } = refreshArgs;\n\n    this.refresh = tokenRefresher;\n    this.currentToken = token ? parseToken(token) : expiredToken;\n    this.refreshProactively = refreshProactively ?? false;\n\n    if (this.refreshProactively) {\n      this.scheduleRefresh();\n    }\n  }\n\n  public async getToken(options?: CommunicationGetTokenOptions): Promise<AccessToken> {\n    if (!this.isTokenExpiringSoon(this.currentToken)) {\n      return this.currentToken;\n    }\n\n    if (!this.isTokenValid(this.currentToken)) {\n      const updatePromise = this.updateTokenAndReschedule(options?.abortSignal);\n      await updatePromise;\n    }\n\n    return this.currentToken;\n  }\n\n  public dispose(): void {\n    this.disposed = true;\n    this.activeTokenFetching = null;\n    this.activeTokenUpdating = null;\n    this.currentToken = expiredToken;\n    if (this.activeTimeout) {\n      clearTimeout(this.activeTimeout);\n    }\n  }\n\n  private async updateTokenAndReschedule(abortSignal?: AbortSignalLike): Promise<void> {\n    if (this.activeTokenUpdating) {\n      return this.activeTokenUpdating;\n    }\n    this.activeTokenUpdating = this.refreshTokenAndReschedule(abortSignal);\n    try {\n      await this.activeTokenUpdating;\n    } finally {\n      this.activeTokenUpdating = null;\n    }\n  }\n\n  private async refreshTokenAndReschedule(abortSignal?: AbortSignalLike): Promise<void> {\n    const newToken = await this.refreshToken(abortSignal);\n\n    if (!this.isTokenValid(newToken)) {\n      throw new Error(\"The token returned from the tokenRefresher is expired.\");\n    }\n\n    this.currentToken = newToken;\n    if (this.refreshProactively) {\n      this.scheduleRefresh();\n    }\n  }\n\n  private async refreshToken(abortSignal?: AbortSignalLike): Promise<AccessToken> {\n    try {\n      if (!this.activeTokenFetching) {\n        this.activeTokenFetching = this.refresh(abortSignal);\n      }\n      return parseToken(await this.activeTokenFetching);\n    } finally {\n      this.activeTokenFetching = null;\n    }\n  }\n\n  private scheduleRefresh(): void {\n    if (this.disposed) {\n      return;\n    }\n    if (this.activeTimeout) {\n      clearTimeout(this.activeTimeout);\n    }\n    const tokenTtlInMs = this.currentToken.expiresOnTimestamp - Date.now();\n    let timespanInMs = null;\n\n    if (this.isTokenExpiringSoon(this.currentToken)) {\n      // Schedule the next refresh for when it reaches a certain percentage of the remaining lifetime.\n      timespanInMs = tokenTtlInMs * this.refreshAfterLifetimePercentage;\n    } else {\n      // Schedule the next refresh for when it gets in to the soon-to-expire window.\n      timespanInMs = tokenTtlInMs - this.expiringSoonIntervalInMs;\n    }\n\n    this.activeTimeout = setTimeout(() => this.updateTokenAndReschedule(), timespanInMs);\n  }\n\n  private isTokenValid(token: AccessToken): boolean {\n    return token && Date.now() < token.expiresOnTimestamp;\n  }\n\n  private isTokenExpiringSoon(token: AccessToken): boolean {\n    return !token || Date.now() >= token.expiresOnTimestamp - this.expiringSoonIntervalInMs;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AccessToken } from \"@azure/core-auth\";\nimport { TokenCredential } from \"./communicationTokenCredential\";\n\n/**\n * StaticTokenCredential\n */\nexport class StaticTokenCredential implements TokenCredential {\n  constructor(private readonly token: AccessToken) {}\n\n  public async getToken(): Promise<AccessToken> {\n    return this.token;\n  }\n\n  public dispose(): void {\n    /* intentionally empty */\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  AutoRefreshTokenCredential,\n  CommunicationTokenRefreshOptions,\n} from \"./autoRefreshTokenCredential\";\nimport {\n  CommunicationGetTokenOptions,\n  CommunicationTokenCredential,\n  TokenCredential,\n} from \"./communicationTokenCredential\";\nimport { AccessToken } from \"@azure/core-auth\";\nimport { StaticTokenCredential } from \"./staticTokenCredential\";\nimport { parseToken } from \"./tokenParser\";\n\n/**\n * The CommunicationTokenCredential implementation with support for proactive token refresh.\n */\n\nexport class AzureCommunicationTokenCredential implements CommunicationTokenCredential {\n  private readonly tokenCredential: TokenCredential;\n  private disposed = false;\n\n  /**\n   * Creates an instance of CommunicationTokenCredential with a static token and no proactive refreshing.\n   * @param token - A user access token issued by Communication Services.\n   */\n  constructor(token: string);\n  /**\n   * Creates an instance of CommunicationTokenCredential with a lambda to get a token and options\n   * to configure proactive refreshing.\n   * @param refreshOptions - Options to configure refresh and opt-in to proactive refreshing.\n   */\n  constructor(refreshOptions: CommunicationTokenRefreshOptions);\n  constructor(tokenOrRefreshOptions: string | CommunicationTokenRefreshOptions) {\n    if (typeof tokenOrRefreshOptions === \"string\") {\n      this.tokenCredential = new StaticTokenCredential(parseToken(tokenOrRefreshOptions));\n    } else {\n      this.tokenCredential = new AutoRefreshTokenCredential(tokenOrRefreshOptions);\n    }\n  }\n\n  /**\n   * Gets an `AccessToken` for the user. Throws if already disposed.\n   * @param abortSignal - An implementation of `AbortSignalLike` to cancel the operation.\n   */\n  public async getToken(options?: CommunicationGetTokenOptions): Promise<AccessToken> {\n    this.throwIfDisposed();\n    const token = await this.tokenCredential.getToken(options);\n    this.throwIfDisposed();\n    return token;\n  }\n\n  /**\n   * Disposes the CommunicationTokenCredential and cancels any internal auto-refresh operation.\n   */\n  public dispose(): void {\n    this.disposed = true;\n    this.tokenCredential.dispose();\n  }\n\n  private throwIfDisposed(): void {\n    if (this.disposed) {\n      throw new Error(\"User credential is disposed\");\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { createHash, createHmac } from \"crypto\";\n\nexport const shaHash = async (content: string): Promise<string> =>\n  createHash(\"sha256\").update(content).digest(\"base64\");\n\nexport const shaHMAC = async (secret: string, content: string): Promise<string> => {\n  const decodedSecret = Buffer.from(secret, \"base64\");\n\n  return createHmac(\"sha256\", decodedSecret).update(content).digest(\"base64\");\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  PipelinePolicy,\n  PipelineRequest,\n  PipelineResponse,\n  SendRequest,\n} from \"@azure/core-rest-pipeline\";\nimport { shaHMAC, shaHash } from \"./cryptoUtils\";\nimport { KeyCredential } from \"@azure/core-auth\";\nimport { isNode } from \"@azure/core-util\";\n\n/**\n * CommunicationKeyCredentialPolicy provides a means of signing requests made through\n * the SmsClient.\n */\nconst communicationAccessKeyCredentialPolicy = \"CommunicationAccessKeyCredentialPolicy\";\n\n/**\n * Creates an HTTP pipeline policy to authenticate a request using a `KeyCredential`.\n * @hidden\n *\n * @param credential - The key credential.\n */\nexport function createCommunicationAccessKeyCredentialPolicy(\n  credential: KeyCredential,\n): PipelinePolicy {\n  return {\n    name: communicationAccessKeyCredentialPolicy,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      const verb = request.method.toUpperCase();\n      const utcNow = new Date().toUTCString();\n      const contentHash = await shaHash(request.body?.toString() || \"\");\n      const dateHeader = \"x-ms-date\";\n      const signedHeaders = `${dateHeader};host;x-ms-content-sha256`;\n\n      const url = new URL(request.url);\n      const query = url.searchParams.toString();\n      const urlPathAndQuery = query ? `${url.pathname}?${query}` : url.pathname;\n      const port = url.port;\n      const hostAndPort = port ? `${url.host}:${port}` : url.host;\n\n      const stringToSign = `${verb}\\n${urlPathAndQuery}\\n${utcNow};${hostAndPort};${contentHash}`;\n      const signature = await shaHMAC(credential.key, stringToSign);\n\n      if (isNode) {\n        request.headers.set(\"Host\", hostAndPort || \"\");\n      }\n\n      request.headers.set(dateHeader, utcNow);\n      request.headers.set(\"x-ms-content-sha256\", contentHash);\n      request.headers.set(\n        \"Authorization\",\n        `HMAC-SHA256 SignedHeaders=${signedHeaders}&Signature=${signature}`,\n      );\n      return next(request);\n    },\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  BearerTokenAuthenticationPolicyOptions,\n  PipelinePolicy,\n  bearerTokenAuthenticationPolicy,\n} from \"@azure/core-rest-pipeline\";\nimport { KeyCredential, TokenCredential, isTokenCredential } from \"@azure/core-auth\";\nimport { createCommunicationAccessKeyCredentialPolicy } from \"./communicationAccessKeyCredentialPolicy\";\n/**\n * Creates a pipeline policy to authenticate request based\n * on the credential passed in.\n * @hidden\n *\n * @param credential - The KeyCredential or TokenCredential.\n */\nexport function createCommunicationAuthPolicy(\n  credential: KeyCredential | TokenCredential,\n): PipelinePolicy {\n  if (isTokenCredential(credential)) {\n    const policyOptions: BearerTokenAuthenticationPolicyOptions = {\n      credential: credential,\n      scopes: [\"https://communication.azure.com//.default\"],\n    };\n    return bearerTokenAuthenticationPolicy(policyOptions);\n  } else {\n    return createCommunicationAccessKeyCredentialPolicy(credential);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AzureKeyCredential, KeyCredential } from \"@azure/core-auth\";\n/**\n * Represents different properties of connection string\n * using format \"/endpoint=(.*);accesskey=(.*)\".\n * @hidden\n */\nexport interface EndpointCredential {\n  /**\n   * The endpoint as string\n   */\n  endpoint: string;\n  /**\n   * The access key represented as a KeyCredential object\n   */\n  credential: KeyCredential;\n}\n\n// TODO: update when connection string format is finalized\nconst CONNECTION_STRING_REGEX = /endpoint=(.*);accesskey=(.*)/i;\n\nconst tryParseConnectionString = (s: string): EndpointCredential | undefined => {\n  const match = s.match(CONNECTION_STRING_REGEX);\n  if (match?.[1] && match[2]) {\n    return { endpoint: match[1], credential: new AzureKeyCredential(match[2]) };\n  }\n  return undefined;\n};\n/**\n * Returns an EndpointCredential to easily access properties of the connection string.\n * @hidden\n *\n * @param connectionString - The connection string to parse\n * @returns Object to access the endpoint and the credentials\n */\nexport const parseConnectionString = (connectionString: string): EndpointCredential => {\n  const parsedConnectionString = tryParseConnectionString(connectionString);\n  if (parsedConnectionString) {\n    return parsedConnectionString;\n  } else {\n    throw new Error(`Invalid connection string ${connectionString}`);\n  }\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { KeyCredential, TokenCredential, isTokenCredential } from \"@azure/core-auth\";\nimport { parseConnectionString } from \"./connectionString\";\n\nconst isValidEndpoint = (host: string): boolean => {\n  const url = new URL(host);\n\n  return (\n    !!url.protocol?.match(/^http[s]?/) &&\n    url.host !== undefined &&\n    url.host !== \"\" &&\n    (url.pathname === undefined || url.pathname === \"\" || url.pathname === \"/\")\n  );\n};\n\nconst assertValidEndpoint = (host: string): void => {\n  if (!isValidEndpoint(host)) {\n    throw new Error(`Invalid endpoint url ${host}`);\n  }\n};\n\n/**\n * Checks whether a value is a KeyCredential.\n *\n * @param credential - The credential being checked.\n */\nexport const isKeyCredential = (credential: unknown): credential is KeyCredential => {\n  const castCredential = credential as {\n    key: unknown;\n    getToken: unknown;\n  };\n  return (\n    castCredential &&\n    typeof castCredential.key === \"string\" &&\n    castCredential.getToken === undefined\n  );\n};\n\n/**\n * The URL and credential from parsing the arguments of a communication client.\n * @hidden\n */\nexport type UrlWithCredential = {\n  url: string;\n  credential: TokenCredential | KeyCredential;\n};\n\n/**\n * Parses arguments passed to a communication client.\n * @hidden\n */\nexport const parseClientArguments = (\n  connectionStringOrUrl: string,\n  credentialOrOptions?: unknown,\n): UrlWithCredential => {\n  if (isKeyCredential(credentialOrOptions) || isTokenCredential(credentialOrOptions)) {\n    assertValidEndpoint(connectionStringOrUrl);\n    return { url: connectionStringOrUrl, credential: credentialOrOptions };\n  } else {\n    const { endpoint: host, credential } = parseConnectionString(connectionStringOrUrl);\n    assertValidEndpoint(host);\n    return { url: host, credential };\n  }\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * Identifies a communication participant.\n */\nexport type CommunicationIdentifier =\n  | CommunicationUserIdentifier\n  | PhoneNumberIdentifier\n  | MicrosoftTeamsUserIdentifier\n  | MicrosoftTeamsAppIdentifier\n  | UnknownIdentifier;\n\n/**\n * An Azure Communication user.\n */\nexport interface CommunicationUserIdentifier {\n  /**\n   * Id of the CommunicationUser as returned from the Communication Service.\n   */\n  communicationUserId: string;\n}\n\n/**\n * A phone number.\n */\nexport interface PhoneNumberIdentifier {\n  /**\n   * Optional raw id of the phone number.\n   */\n  rawId?: string;\n  /**\n   * The phone number in E.164 format.\n   */\n  phoneNumber: string;\n}\n\n/**\n * A Microsoft Teams user.\n */\nexport interface MicrosoftTeamsUserIdentifier {\n  /**\n   * Optional raw id of the Microsoft Teams user.\n   */\n  rawId?: string;\n\n  /**\n   * Id of the Microsoft Teams user. If the user isn't anonymous, the id is the AAD object id of the user.\n   */\n  microsoftTeamsUserId: string;\n\n  /**\n   * True if the user is anonymous, for example when joining a meeting with a share link. If missing, the user is not anonymous.\n   */\n  isAnonymous?: boolean;\n\n  /**\n   * The cloud that the Microsoft Teams user belongs to. If missing, the cloud is \"public\".\n   */\n  cloud?: \"public\" | \"dod\" | \"gcch\";\n}\n\n/**\n * A Microsoft Teams App.\n */\nexport interface MicrosoftTeamsAppIdentifier {\n  /**\n   * Optional raw id of the Microsoft Teams App.\n   */\n  rawId?: string;\n\n  /**\n   * The unique Microsoft Teams app ID.\n   */\n  teamsAppId: string;\n\n  /**\n   * The cloud that the Microsoft Temas App belongs to. If missing, the cloud is \"public\".\n   */\n  cloud?: \"public\" | \"dod\" | \"gcch\";\n}\n\n/**\n * An unknown identifier that doesn't fit any of the other identifier types.\n */\nexport interface UnknownIdentifier {\n  /**\n   * Id of the UnknownIdentifier.\n   */\n  id: string;\n}\n\n/**\n * Tests an Identifier to determine whether it implements CommunicationUserIdentifier.\n *\n * @param identifier - The assumed CommunicationUserIdentifier to be tested.\n */\nexport const isCommunicationUserIdentifier = (\n  identifier: CommunicationIdentifier,\n): identifier is CommunicationUserIdentifier => {\n  return typeof (identifier as any).communicationUserId === \"string\";\n};\n\n/**\n * Tests an Identifier to determine whether it implements PhoneNumberIdentifier.\n *\n * @param identifier - The assumed PhoneNumberIdentifier to be tested.\n */\nexport const isPhoneNumberIdentifier = (\n  identifier: CommunicationIdentifier,\n): identifier is PhoneNumberIdentifier => {\n  return typeof (identifier as any).phoneNumber === \"string\";\n};\n\n/**\n * Tests an Identifier to determine whether it implements MicrosoftTeamsUserIdentifier.\n *\n * @param identifier - The assumed available to be tested.\n */\nexport const isMicrosoftTeamsUserIdentifier = (\n  identifier: CommunicationIdentifier,\n): identifier is MicrosoftTeamsUserIdentifier => {\n  return typeof (identifier as any).microsoftTeamsUserId === \"string\";\n};\n\n/**\n * Tests an Identifier to determine whether it implements MicrosoftTeamsAppIdentifier.\n *\n * @param identifier - The assumed available to be tested.\n */\nexport const isMicrosoftTeamsAppIdentifier = (\n  identifier: CommunicationIdentifier,\n): identifier is MicrosoftTeamsAppIdentifier => {\n  return typeof (identifier as any).teamsAppId === \"string\";\n};\n\n/**\n * Tests an Identifier to determine whether it implements UnknownIdentifier.\n *\n * @param identifier - The assumed UnknownIdentifier to be tested.\n */\nexport const isUnknownIdentifier = (\n  identifier: CommunicationIdentifier,\n): identifier is UnknownIdentifier => {\n  return typeof (identifier as any).id === \"string\";\n};\n\n/**\n * The CommunicationIdentifierKind is a discriminated union that adds a property `kind` to an Identifier.\n */\nexport type CommunicationIdentifierKind =\n  | CommunicationUserKind\n  | PhoneNumberKind\n  | MicrosoftTeamsUserKind\n  | MicrosoftTeamsAppKind\n  | UnknownIdentifierKind;\n\n/**\n * IdentifierKind for a CommunicationUserIdentifier.\n */\nexport interface CommunicationUserKind extends CommunicationUserIdentifier {\n  /**\n   * The identifier kind.\n   */\n  kind: \"communicationUser\";\n}\n\n/**\n * IdentifierKind for a PhoneNumberIdentifier.\n */\nexport interface PhoneNumberKind extends PhoneNumberIdentifier {\n  /**\n   * The identifier kind.\n   */\n  kind: \"phoneNumber\";\n}\n\n/**\n * IdentifierKind for a MicrosoftTeamsUserIdentifier.\n */\nexport interface MicrosoftTeamsUserKind extends MicrosoftTeamsUserIdentifier {\n  /**\n   * The identifier kind.\n   */\n  kind: \"microsoftTeamsUser\";\n}\n\n/**\n * IdentifierKind for a MicrosoftTeamsAppIdentifier.\n */\nexport interface MicrosoftTeamsAppKind extends MicrosoftTeamsAppIdentifier {\n  /**\n   * The identifier kind.\n   */\n  kind: \"microsoftTeamsApp\";\n}\n\n/**\n * IdentifierKind for UnknownIdentifier.\n */\nexport interface UnknownIdentifierKind extends UnknownIdentifier {\n  /**\n   * The identifier kind.\n   */\n  kind: \"unknown\";\n}\n\n/**\n * Returns the CommunicationIdentifierKind for a given CommunicationIdentifier. Returns undefined if the kind couldn't be inferred.\n *\n * @param identifier - The identifier whose kind is to be inferred.\n */\nexport const getIdentifierKind = (\n  identifier: CommunicationIdentifier,\n): CommunicationIdentifierKind => {\n  if (isCommunicationUserIdentifier(identifier)) {\n    return { ...identifier, kind: \"communicationUser\" };\n  }\n  if (isPhoneNumberIdentifier(identifier)) {\n    return { ...identifier, kind: \"phoneNumber\" };\n  }\n  if (isMicrosoftTeamsUserIdentifier(identifier)) {\n    return { ...identifier, kind: \"microsoftTeamsUser\" };\n  }\n  if (isMicrosoftTeamsAppIdentifier(identifier)) {\n    return { ...identifier, kind: \"microsoftTeamsApp\" };\n  }\n  return { ...identifier, kind: \"unknown\" };\n};\n\n/**\n * Returns the rawId for a given CommunicationIdentifier. You can use the rawId for encoding the identifier and then use it as a key in a database.\n *\n * @param identifier - The identifier to be translated to its rawId.\n */\nexport const getIdentifierRawId = (identifier: CommunicationIdentifier): string => {\n  const identifierKind = getIdentifierKind(identifier);\n  switch (identifierKind.kind) {\n    case \"communicationUser\":\n      return identifierKind.communicationUserId;\n    case \"microsoftTeamsUser\": {\n      const { microsoftTeamsUserId, rawId, cloud, isAnonymous } = identifierKind;\n      if (rawId) return rawId;\n      if (isAnonymous) return `8:teamsvisitor:${microsoftTeamsUserId}`;\n      switch (cloud) {\n        case \"dod\":\n          return `8:dod:${microsoftTeamsUserId}`;\n        case \"gcch\":\n          return `8:gcch:${microsoftTeamsUserId}`;\n        case \"public\":\n          return `8:orgid:${microsoftTeamsUserId}`;\n      }\n      return `8:orgid:${microsoftTeamsUserId}`;\n    }\n    case \"microsoftTeamsApp\": {\n      const { teamsAppId, rawId, cloud } = identifierKind;\n      if (rawId) return rawId;\n      switch (cloud) {\n        case \"dod\":\n          return `28:dod:${teamsAppId}`;\n        case \"gcch\":\n          return `28:gcch:${teamsAppId}`;\n      }\n      return `28:orgid:${teamsAppId}`;\n    }\n    case \"phoneNumber\": {\n      const { phoneNumber, rawId } = identifierKind;\n      if (rawId) return rawId;\n      return `4:${phoneNumber}`;\n    }\n    case \"unknown\": {\n      return identifierKind.id;\n    }\n  }\n};\n\nconst buildMicrosoftTeamsAppIdentifier = (\n  teamsAppId: string,\n  cloud: \"public\" | \"dod\" | \"gcch\",\n): CommunicationIdentifierKind => {\n  return {\n    kind: \"microsoftTeamsApp\",\n    teamsAppId: teamsAppId,\n    cloud: cloud,\n  };\n};\n\nconst buildMicrosoftTeamsUserIdentifier = (\n  id: string,\n  cloud: \"public\" | \"dod\" | \"gcch\",\n  isAnonymous: boolean,\n): CommunicationIdentifierKind => {\n  return {\n    kind: \"microsoftTeamsUser\",\n    microsoftTeamsUserId: id,\n    isAnonymous: isAnonymous,\n    cloud: cloud,\n  };\n};\n\n/**\n * Creates a CommunicationIdentifierKind from a given rawId. When storing rawIds use this function to restore the identifier that was encoded in the rawId.\n *\n * @param rawId - The rawId to be translated to its identifier representation.\n */\nexport const createIdentifierFromRawId = (rawId: string): CommunicationIdentifierKind => {\n  if (rawId.startsWith(\"4:\")) {\n    return { kind: \"phoneNumber\", phoneNumber: `${rawId.substring(\"4:\".length)}` };\n  }\n\n  const segments = rawId.split(\":\");\n  if (segments.length !== 3) {\n    return { kind: \"unknown\", id: rawId };\n  }\n\n  const prefix = `${segments[0]}:${segments[1]}:`;\n  const suffix = segments[2];\n\n  switch (prefix) {\n    case \"8:teamsvisitor:\":\n      return { kind: \"microsoftTeamsUser\", microsoftTeamsUserId: suffix, isAnonymous: true };\n    case \"8:orgid:\":\n      return buildMicrosoftTeamsUserIdentifier(suffix, \"public\", false);\n    case \"8:dod:\":\n      return buildMicrosoftTeamsUserIdentifier(suffix, \"dod\", false);\n    case \"8:gcch:\":\n      return buildMicrosoftTeamsUserIdentifier(suffix, \"gcch\", false);\n    case \"8:acs:\":\n    case \"8:spool:\":\n    case \"8:dod-acs:\":\n    case \"8:gcch-acs:\":\n      return { kind: \"communicationUser\", communicationUserId: rawId };\n    case \"28:orgid:\":\n      return buildMicrosoftTeamsAppIdentifier(suffix, \"public\");\n    case \"28:gcch:\":\n      return buildMicrosoftTeamsAppIdentifier(suffix, \"gcch\");\n    case \"28:dod:\":\n      return buildMicrosoftTeamsAppIdentifier(suffix, \"dod\");\n  }\n  return { kind: \"unknown\", id: rawId };\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  CommunicationIdentifier,\n  CommunicationIdentifierKind,\n  getIdentifierKind,\n  getIdentifierRawId,\n} from \"./identifierModels\";\n\n/**\n * @hidden\n * Identifies a participant in Azure Communication services. A participant is, for example, a phone number or an Azure communication user. This model must be interpreted as a union: Apart from rawId, at most one further property may be set.\n */\nexport interface SerializedCommunicationIdentifier {\n  /**\n   * Kind of the identifier, optional.\n   */\n  kind?: string;\n  /**\n   * Raw Id of the identifier. Optional in requests, required in responses.\n   */\n  rawId?: string;\n  /**\n   * The communication user.\n   */\n  communicationUser?: SerializedCommunicationUserIdentifier;\n  /**\n   * The phone number.\n   */\n  phoneNumber?: SerializedPhoneNumberIdentifier;\n  /**\n   * The Microsoft Teams user.\n   */\n  microsoftTeamsUser?: SerializedMicrosoftTeamsUserIdentifier;\n  /**\n   * The Microsoft Teams App.\n   */\n  microsoftTeamsApp?: SerializedMicrosoftTeamsAppIdentifier;\n}\n\n/**\n * @hidden\n * A user that got created with an Azure Communication Services resource.\n */\nexport interface SerializedCommunicationUserIdentifier {\n  /**\n   * The Id of the communication user.\n   */\n  id: string;\n}\n\n/**\n * @hidden\n * A phone number.\n */\nexport interface SerializedPhoneNumberIdentifier {\n  /**\n   * The phone number in E.164 format.\n   */\n  value: string;\n}\n\n/**\n * @hidden\n * A Microsoft Teams user.\n */\nexport interface SerializedMicrosoftTeamsUserIdentifier {\n  /**\n   * The Id of the Microsoft Teams user. If not anonymous, this is the AAD object Id of the user.\n   */\n  userId: string;\n  /**\n   * True if the Microsoft Teams user is anonymous. By default false if missing.\n   */\n  isAnonymous?: boolean;\n  /**\n   * The cloud that the Microsoft Teams user belongs to. By default 'public' if missing.\n   */\n  cloud?: SerializedCommunicationCloudEnvironment;\n}\n\n/**\n * @hidden\n * A Microsoft Teams App.\n */\nexport interface SerializedMicrosoftTeamsAppIdentifier {\n  /**\n   * Id of the Microsoft Teams App.\n   */\n  appId: string;\n\n  /**\n   * The cloud that the Microsoft Teams App belongs to. By default 'public' if missing.\n   */\n  cloud?: SerializedCommunicationCloudEnvironment;\n}\n\n/**\n * @hidden\n * Defines values for CommunicationCloudEnvironmentModel.\n */\nexport type SerializedCommunicationCloudEnvironment = \"public\" | \"dod\" | \"gcch\";\n\nconst assertNotNullOrUndefined = <\n  T extends Record<string, unknown>,\n  P extends keyof T,\n  Q extends string & keyof T[P],\n>(\n  obj: T,\n  prop: Q,\n): Required<Required<T>[P]>[Q] => {\n  const subObjName = Object.keys(obj)[0];\n  const subObj = (obj as any)[subObjName];\n  if (prop in subObj) {\n    return subObj[prop];\n  }\n  throw new Error(`Property ${prop} is required for identifier of type ${subObjName}.`);\n};\n\nconst assertMaximumOneNestedModel = (identifier: SerializedCommunicationIdentifier): void => {\n  const presentProperties: string[] = [];\n  if (identifier.communicationUser !== undefined) {\n    presentProperties.push(\"communicationUser\");\n  }\n  if (identifier.microsoftTeamsUser !== undefined) {\n    presentProperties.push(\"microsoftTeamsUser\");\n  }\n  if (identifier.microsoftTeamsApp !== undefined) {\n    presentProperties.push(\"microsoftTeamsApp\");\n  }\n  if (identifier.phoneNumber !== undefined) {\n    presentProperties.push(\"phoneNumber\");\n  }\n  if (presentProperties.length > 1) {\n    throw new Error(\n      `Only one of the properties in ${JSON.stringify(presentProperties)} should be present.`,\n    );\n  }\n};\n\n/**\n * @hidden\n * Translates a CommunicationIdentifier to its serialized format for sending a request.\n * @param identifier - The CommunicationIdentifier to be serialized.\n */\nexport const serializeCommunicationIdentifier = (\n  identifier: CommunicationIdentifier,\n): SerializedCommunicationIdentifier => {\n  const identifierKind = getIdentifierKind(identifier);\n  switch (identifierKind.kind) {\n    case \"communicationUser\":\n      return {\n        rawId: getIdentifierRawId(identifierKind),\n        communicationUser: { id: identifierKind.communicationUserId },\n      };\n    case \"phoneNumber\":\n      return {\n        rawId: identifierKind.rawId ?? getIdentifierRawId(identifierKind),\n        phoneNumber: {\n          value: identifierKind.phoneNumber,\n        },\n      };\n    case \"microsoftTeamsUser\":\n      return {\n        rawId: identifierKind.rawId ?? getIdentifierRawId(identifierKind),\n        microsoftTeamsUser: {\n          userId: identifierKind.microsoftTeamsUserId,\n          isAnonymous: identifierKind.isAnonymous ?? false,\n          cloud: identifierKind.cloud ?? \"public\",\n        },\n      };\n    case \"microsoftTeamsApp\":\n      return {\n        rawId: identifierKind.rawId ?? getIdentifierRawId(identifierKind),\n        microsoftTeamsApp: {\n          appId: identifierKind.teamsAppId,\n          cloud: identifierKind.cloud ?? \"public\",\n        },\n      };\n    case \"unknown\":\n      return { rawId: identifierKind.id };\n    default:\n      throw new Error(`Can't serialize an identifier with kind ${(identifierKind as any).kind}`);\n  }\n};\n\nconst getKind = (serializedIdentifier: SerializedCommunicationIdentifier): string => {\n  if (serializedIdentifier.communicationUser) {\n    return \"communicationUser\";\n  }\n\n  if (serializedIdentifier.phoneNumber) {\n    return \"phoneNumber\";\n  }\n\n  if (serializedIdentifier.microsoftTeamsUser) {\n    return \"microsoftTeamsUser\";\n  }\n\n  if (serializedIdentifier.microsoftTeamsApp) {\n    return \"microsoftTeamsApp\";\n  }\n\n  return \"unknown\";\n};\n\n/**\n * @hidden\n * Translates the serialized format of a communication identifier to CommunicationIdentifier.\n * @param serializedIdentifier - The SerializedCommunicationIdentifier to be deserialized.\n */\nexport const deserializeCommunicationIdentifier = (\n  serializedIdentifier: SerializedCommunicationIdentifier,\n): CommunicationIdentifierKind => {\n  assertMaximumOneNestedModel(serializedIdentifier);\n\n  const { communicationUser, microsoftTeamsUser, microsoftTeamsApp, phoneNumber } =\n    serializedIdentifier;\n  const kind = serializedIdentifier.kind ?? getKind(serializedIdentifier);\n\n  if (kind === \"communicationUser\" && communicationUser) {\n    return {\n      kind: \"communicationUser\",\n      communicationUserId: assertNotNullOrUndefined({ communicationUser }, \"id\"),\n    };\n  }\n  if (kind === \"phoneNumber\" && phoneNumber) {\n    return {\n      kind: \"phoneNumber\",\n      phoneNumber: assertNotNullOrUndefined({ phoneNumber }, \"value\"),\n      rawId: assertNotNullOrUndefined({ phoneNumber: serializedIdentifier }, \"rawId\"),\n    };\n  }\n  if (kind === \"microsoftTeamsUser\" && microsoftTeamsUser) {\n    return {\n      kind: \"microsoftTeamsUser\",\n      microsoftTeamsUserId: assertNotNullOrUndefined({ microsoftTeamsUser }, \"userId\"),\n      isAnonymous: assertNotNullOrUndefined({ microsoftTeamsUser }, \"isAnonymous\"),\n      cloud: assertNotNullOrUndefined({ microsoftTeamsUser }, \"cloud\"),\n      rawId: assertNotNullOrUndefined({ microsoftTeamsUser: serializedIdentifier }, \"rawId\"),\n    };\n  }\n  if (kind === \"microsoftTeamsApp\" && microsoftTeamsApp) {\n    return {\n      kind: \"microsoftTeamsApp\",\n      teamsAppId: assertNotNullOrUndefined({ microsoftTeamsApp }, \"appId\"),\n      cloud: assertNotNullOrUndefined({ microsoftTeamsApp }, \"cloud\"),\n      rawId: assertNotNullOrUndefined({ microsoftTeamsApp: serializedIdentifier }, \"rawId\"),\n    };\n  }\n  return {\n    kind: \"unknown\",\n    id: assertNotNullOrUndefined({ unknown: serializedIdentifier }, \"rawId\"),\n  };\n};\n"],"names":["jwtDecode","createHash","createHmac","isNode","isTokenCredential","bearerTokenAuthenticationPolicy","AzureKeyCredential"],"mappings":"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"}